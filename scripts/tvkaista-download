#!/usr/bin/python
# coding=UTF-8
#
# tvkaista-download - Batch download recordings from tvkaista.fi PVR service
#
# http://code.google.com/p/tvkaista-download/
#
# Copyright (c) 2009 Matti Pöllä
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

__version__ = "$Revision$"
# $Source$

import urllib, urllib2 , re, os, htmlentitydefs, sys, getopt, httplib2, shutil, time, datetime
from string import split, replace, find
from math import floor
from xml.dom import minidom

class Timer:
    """
    The Timer class is used as a stopwatch to estimate the 
    download speed and remaining time.
    """
    def __init__(self):
        self.t = time.time()
    def gettime(self):
        return time.time() - self.t
    def reset(self):
        self.t = time.time()
        
        
class Program:
    """
    The Programm class encapsulates a downloadable item.
    """
    def __init__(self,pid,ptit,plen,pdt):
        self.idn = pid
        self.length = int(plen)
        self.title = ptit
        self.date = time.strftime("%Y-%m-%d",time.localtime(pdt))
        self.time = "klo " + time.strftime("%H:%M",time.localtime(pdt))
        if (alpha):
            urlbase = "@alpha.tvkaista.fi/recordings/download/"
        else:
            urlbase = "@www.tvkaista.fi/netpvr/Download/"
        self.vurl = "http://"+settings['username']+":"+settings['password']+urlbase+pid+"."+filesuffix(settings['format'])
        self.surl = "http://"+settings['username']+":"+settings['password']+urlbase+pid+""+SUB_SUFFIX
        self.vfile = settings['downloaddir'] + ptit + "_" + self.date + "_" + pid + "." + filesuffix(settings['format'])
        self.sfile = settings['downloaddir'] + ptit + "_" + self.date + "_" + pid + "." + SUB_SUFFIX

    def download(self):
        """
        The download method executes the actual download process of 
        a video/subtitle file.
        """
        print self.label()        
        if (os.path.exists(self.vfile)):
            sys.stdout.write("\r["+BAR_WIDTH*'='+'] (done)\n')
        else:
            try:
                cursor_hide()
                #print "Trying to download from "+ self.vurl
                urllib.urlretrieve(self.vurl, self.vfile+TMP_SUFFIX, reporthook=progressbar)
                cursor_unhide()
                if (os.path.exists(self.vfile+TMP_SUFFIX)):
                    shutil.move(self.vfile+TMP_SUFFIX, self.vfile)
            except:
                cursor_unhide()
                print "\nDownload interrupted"
        # Download subtitle file. Remove if empty.  
        if (not os.path.exists(self.sfile)):
            try:
                print "Trying to download from "+ self.surl
                urllib.urlretrieve(self.surl, self.sfile+TMP_SUFFIX)
                if (os.path.exists(self.sfile+TMP_SUFFIX)):
                    shutil.move(self.sfile+TMP_SUFFIX, self.sfile)
            except:
                print "\nDownload interrupted"
            if (os.stat(self.sfile).st_size == 0):
                os.remove(self.sfile)
    print "\n"
    
    def downloaded(self):
        return os.path.exists(self.vfile)
    
    def label(self):
        return self.date + " " +  self.time + " " + self.title + \
        " (" + settings['format'] + ", " + dataformat(self.length) + ")"

def cursor_hide():
    """
    Hide the terminal cursor to reduce UI clutter.
    """
    sys.stdout.write('\033[?25l')
    
def cursor_unhide():
    """
    Make the cursor visible again after being
    hidden during the download phase.
    """
    sys.stdout.write('\033[?25h')
    
# Usage message
def usage():
    print "Usage: tvkaista-download [-hvfupsd]"
    print ""
    print " Options:  -h --help  show this message"
    print "           -v         print more information"
    print "           -p         prompt before downloading"
    print "           -s         show list of favourites"
    print "           -u         username"
    print "           -p         password"
    print "           -f         video format (iTunes/flv/h264/ts/help)"
    print "           -d         download directory"
    print "           --alpha    use alpha.tvkaista.fi"
    print ""

# List available video formats.  
def show_format_info():
    print "Available video formats:"
    print " iTunes  300 kbps MPEG-4"
    print " flv       1 Mbps flash video"
    print " h264      2 Mbps MPEG-4"
    print " ts        8 Mbps MPEG-2 transport stream"

# On the first run, prompt the user for settings
def prompt_settings():
    settings = {}
    settings['username'] = raw_input("TVkaista username: ")
    settings['password'] = raw_input("TVkaista password: ")
    settings['format'] = "unknown"
    while (settings['format'] not in formats):
        if (settings['format']) == "help":
            show_format_info()
        settings['format'] = raw_input("File format (iTunes/flv/h264/ts): ")
    settings['downloaddir'] = raw_input("Download directory: ")
    for k in settings.keys():
        print "   " + k + ": " + settings[k]
    while (raw_input("Are these values ok (Y/n)? ") in ['n']):
        prompt_settings()
    return settings

# Write configuration file.  
# Format: option = value
def write_rcfile(settings):
    omask = os.umask(077)
    f = open(getconffile(), 'w')
    f.write("# Configuration file for tvkaista-download script\n")
    f.write("# http://code.google.com/p/tvkaista-download/\n")
    for k in settings.keys():
        f.write(k+" = " + settings[k] + "\n")
    f.close()
    os.umask(omask)

# Read configuration file.  
# Format: option = value
def read_rcfile(filename):
    config = {}
    f = open(filename)
    for line in f:
        if "#" in line:
            line, comment = line.split("#", 1)
        if "=" in line:
            # split on option char:
            key, value = line.split("=", 1)
            key = key.strip()
            value = value.strip()
            config[key] = value
    f.close()
    return config

# Transform month name abbreviations into numbers 1-12.  
def rfc822month(mon):
    return {
      'Jan': '01',
      'Feb': '02',
      'Mar': '03',
      'Apr': '04',
      'May': '05',
      'Jun': '06',
      'Jul': '07',
      'Aug': '08',
      'Sep': '09',
      'Oct': '10',
      'Nov': '11',
      'Dec': '12',
    }[mon]

# Filename suffix for a given video format
def filesuffix(format):
    return {
      'iTunes': 'mp4',
      'flv' :   'flv',
      'h264':   'mp4',
      'ts':     'ts'
    }[format]

# Map from format types into file suffices
def formatstring(format):
    return {
      'iTunes': 'mp4',
      'flv' :   'flv',
      'h264':   'h264',
      'ts':     'ts'
    }[format]

# Remove HTML encoding of strings
# Original code from tvkaistaforxbmc plugin
def unescape(text):
    def fixup(m):
        text = m.group(0)
        if text[:2] == "&#":
            try:
                if text[:3] == "&#x":
                    return unichr(int(text[3:-1], 16))
                else:
                    return unichr(int(text[2:-1]))
            except ValueError:
                pass
        else:
            try:
                text = unichr(htmlentitydefs.name2codepoint[text[1:-1]])
            except KeyError:
                pass
        return text
    return re.sub("&#?\w+;", fixup, text)

# Login to tvkaista.fi (required for each action)
def login():
    loginurl = 'http://www.tvkaista.fi/netpvr/Login'
    body = {'action': 'login', 'username': settings['username'], 'password': settings['password'], 'rememberme':'on'}
    headers = {'Content-type': 'application/x-www-form-urlencoded'}
    response, content = http.request(loginurl, 'POST', headers=headers, body=urllib.urlencode(body))
    return response['set-cookie']

# Download the list of favorite recordings and build a list of download targets.  
# Original code from tvkaistaforxbmc plugin
def feedreader(channel):
    targets = []
    headers['Cookie'] = login()
    curl = 'www.tvkaista.fi/'
    # Use RSS stream for iTunes to read program info.  
    favurl = 'http://www.tvkaista.fi/netpvr/Feed?channel=%s&format=%s&extension=itunes' % (channel,settings['format'])
    response, content = http.request(favurl, 'GET', headers=headers)
    if (response['status'] == '401'):
        print "HTTP/401 (Unauthorized) Could not login to tvkaista.fi."
        sys.exit(1)
    elif (response['status'] == '404'):
        print "HTTP/404 (Not Found) Feed XML file was not found."
        sys.exit(1)

    dom = minidom.parseString(content)
    items = dom.getElementsByTagName('item')
    ret = []
    for i in items:
        ptit = i.getElementsByTagName('title')[0].childNodes[0].nodeValue.replace(" ","_")
        plen = 1;
        pgui= i.getElementsByTagName('guid')[0].childNodes[0].nodeValue
        pdt = time.mktime(time.strptime(i.getElementsByTagName('pubDate')[0].childNodes[0].nodeValue, "%a, %d %b %Y %H:%M:%S +0300"))
        pid = re.compile('http://www.tvkaista.fi/netpvr/Search[?]id=(\d+)').findall(pgui)[0]
        program = Program(pid,ptit,plen,pdt)
        if (prompt and not program.downloaded()):
            print program.label()
	    if (raw_input('Download (Y/n) ') in ['n']):
	        continue
	ret.append(program)
    dom.unlink()
    return ret

# Parse a list of download targets from a RSS file into a list of downloadable objects
def feedreader_alpha(channel):
    targets = []
    favurl = 'http://alpha.tvkaista.fi/feed/playlist/'+formatstring(settings['format'])+'.rss'
    passman = urllib2.HTTPPasswordMgrWithDefaultRealm()
    passman.add_password(None, favurl, settings['username'], settings['password'])
    opener = urllib2.build_opener(urllib2.HTTPBasicAuthHandler(passman))
    urllib2.install_opener(opener)
    try:
        content = urllib2.urlopen(favurl).read()
    except(urllib2.HTTPError):
        print "HTTP 404 Error: " + favurl
        exit(1)
    dom = minidom.parseString(content)
    items = dom.getElementsByTagName('item')
    ret = []
    for i in items:
        ptit = i.getElementsByTagName('title')[0].childNodes[0].nodeValue.replace(" ","_")
        plen = i.getElementsByTagName('enclosure')[0].attributes['length'].value
        plin= i.getElementsByTagName('link')[0].childNodes[0].nodeValue
        pdt = time.mktime(time.strptime(i.getElementsByTagName('pubDate')[0].childNodes[0].nodeValue, "%a, %d %b %Y %H:%M:%S +0000"))
        pid = re.compile('http://alpha.tvkaista.fi/search/[?]id=(\d+)').findall(plin)[0]
        program = Program(pid,ptit,plen,pdt)
        if (prompt and not program.downloaded()):
            print program.label()
	    if (raw_input('Download (Y/n) ') in ['n']):
	        continue
	ret.append(program)
    dom.unlink()
    return ret

# Format raw byte count into reasonable units.  
def dataformat(b):
    if (b < 1024):
        return "%d bytes" % b
    b = b/1024
    if (b < 1024):
       return "%d KiB" % b
    b = b/1024
    if (b < 1024):
        return "%d MiB" % b
    b = b/1024
    return "%d GiB" % b
    
def timeformat(s):
    if (s<0):
        return "00:00:00"
    h = floor(s/(60*60))
    s = s-h*60*60
    m = floor(s/60)
    s = s-m*60
    return "%02d:%02d:%02d" % (h,m,s)

# Progress bar display for urllib.urlretrieve function.  
def progressbar(count, blockSize, totalSize):
    if (totalSize > 0):
        percent = int(count*blockSize*100/totalSize)
        blocks = int(count*blockSize*BAR_WIDTH/totalSize)
    else:
        percent = 0
        blocks = 0
    sys.stdout.write("\r["+blocks*'='+(BAR_WIDTH-blocks)*' '+'] '+'%d%% ' % percent)
    #sys.stdout.write('%d KiB ' % (count * blockSize/(1024)))
    sys.stdout.write('of %s ' % dataformat(totalSize))
    bps_speed = (count*blockSize)/(timer.gettime())
    sys.stdout.write('at %s/s ' % dataformat(bps_speed))
    if bps_speed > 0:
        eta = (totalSize - count*blockSize) / (bps_speed)
    else:
        eta = 0
    sys.stdout.write('ETA: %s' % timeformat(eta))
    sys.stdout.write(4*' ')
    sys.stdout.flush()

# Return a suitable file name for configuration options.  
def getconffile():
    # TODO: OS specific selection of configuration file name.  
    return os.getenv("HOME")+"/.tvkaista-downloadrc"

# Confirm that all required settings have been defined.  
def valid_settings(s,critical):
    for k in att:
        try:
            if (s[k] == None):
                if (critical):
                    print k+" not specified. See \"tvkaista-download --help\""
                    sys.exit(1)
                else:
                    return False
        except KeyError:
            if (critical):
                print k+" not specified. See \"tvkaista-download --help\""
                sys.exit(1)
            else:
                return False
    return True

# Main program
def main(argv):

    global conffile
    global verbose
    global prompt
    global show
    global settings
    global timer
    global alpha
    
    timer = Timer()
    exp_settings = {}

    # Processing of command line options using getopt.  
    try:
        opts, args = getopt.getopt(argv, "hvpsf:u:p:d:", \
                       ["help","verbose","alpha","format=","username=", \
                        "password=","downloaddir="])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()                     
            sys.exit()
        elif opt in ("-v", "--verbose"):
            verbose = True
        elif opt in ("-p", "--prompt"):
            prompt = True
        elif opt in ("--alpha"):
            alpha = True
        elif opt in ("-s", "--show"):
            show = True
        elif opt in ("-f", "--format"):
            exp_settings['format'] = arg
        elif opt in ("-u", "--username"):
            exp_settings['username'] = arg
        elif opt in ("-p", "--password"):
            exp_settings['password'] = arg
        elif opt in ("-d", "--downloaddir"):
            exp_settings['downloaddir'] = arg
    
    # First see whether a configuration file is available.  
    conffile = getconffile()

    if os.path.exists(conffile):
        if (verbose):
            print "Reading configuration from " + conffile
        settings = read_rcfile(conffile)
    else:
        if (not valid_settings(exp_settings, False)):
            settings = prompt_settings()
            write_rcfile(settings)
        
    # Override configuration file if necessary.  
    settings.update(exp_settings)

    # Make sure that all required settings have been defined.  
    valid_settings(settings, True)

    # Debug: print all settings
    #for k in att:
    #    print k+": "+settings[k]

    # Processing of configuration and options is now complete
    # and we're ready to download.
    #targets = feedreader('favourites')
    
    
    if alpha:
        targets = feedreader_alpha('Playlist')
    else:
        targets = feedreader('Playlist')

    # Show list "-s"
    if (show):
        for t in targets:
            if (t.downloaded()):
                print "[*] ",
            else:
                print "[ ] ",
            print t.label()
            
    else:
        [t.download() for t in targets]
    sys.exit()


# File name suffix for incomplete downloads
TMP_SUFFIX = '.part'
SUB_SUFFIX = '.srt'
# Progress bar width
BAR_WIDTH = 70
# HTTP headers
headers = {'Content-type': 'application/x-www-form-urlencoded'}
http = httplib2.Http()
settings = {}
# Required configuration options
att = ['username','password','format','downloaddir']
# Available video formats
formats = ['iTunes','flv','h264','ts']
verbose = False
prompt = False
show = False
alpha = False


if __name__ == "__main__":
    main(sys.argv[1:])

