#!/usr/bin/python
# coding=UTF-8
#
# tvkaista-download - Batch download recordings from tvkaista.fi PVR service
#
# http://code.google.com/p/tvkaista-download/
#
# Copyright (c) 2009 Matti Pöllä
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

__version__ = "$Revision$"
# $Source$

import urllib
import urllib2
import re
import os
import htmlentitydefs
import sys
import getopt
import shutil
import time
import datetime

from string import split, replace, find
from math import floor
from xml.dom import minidom

class Timer:
    """
    The Timer class is used as a stopwatch to estimate the 
    download speed and remaining time.
    """
    def __init__(self):
        self.t = time.time()
    def gettime(self):
        return time.time() - self.t
    def reset(self):
        self.t = time.time()

class Program:
    """
    The Programm class encapsulates a downloadable item.
    """
    def __init__(self,pid,ptit,plen,pdt):
        self.idn = pid
        self.length = int(plen)
        self.title = ptit
        self.date = time.strftime("%Y-%m-%d",time.localtime(pdt))
        self.time = "klo " + time.strftime("%H:%M",time.localtime(pdt))
        if (alpha):
            urlbase = "@alpha.tvkaista.fi/recordings/download/"
        else:
            urlbase = "@www.tvkaista.fi/netpvr/Download/"
        self.vurl = "http://" + settings['username'] + ":" + \
                    settings['password'] + urlbase+pid + "." + \
                    filesuffix(settings['format'])
        self.surl = "http://" + settings['username'] + ":" + \
                    settings['password'] + urlbase+pid + "" + \
                    SUB_SUFFIX
        self.vfile = settings['downloaddir'] + ptit.replace(" ","_") + "_" + \
                     self.date + "_" + pid + "." + \
                     filesuffix(settings['format'])
        self.sfile = settings['downloaddir'] + ptit.replace(" ","_") + "_" + \
                     self.date + "_" + pid + "" + SUB_SUFFIX

    def download(self):
        """
        The download method executes the actual download process of 
        a video/subtitle file.
        """
        print self.label()
        if (os.path.exists(self.vfile)):
            sys.stdout.write("\r[" + BAR_WIDTH * '=' + '] (done)\n')
        else:
            try:
                cursor_hide()
                urllib.urlretrieve(self.vurl, self.vfile + TMP_SUFFIX, \
                reporthook=progressbar)
                cursor_unhide()
                if (os.path.exists(self.vfile + TMP_SUFFIX)):
                    shutil.move(self.vfile+TMP_SUFFIX, self.vfile)
		print "\n"
            except:
                cursor_unhide()
                print "\nDownload interrupted"
        # Download subtitle file. Remove if empty.  
        if (not os.path.exists(self.sfile)):
            try:
                urllib.urlretrieve(self.surl, self.sfile + TMP_SUFFIX)
                if (os.path.exists(self.sfile + TMP_SUFFIX)):
                    shutil.move(self.sfile + TMP_SUFFIX, self.sfile)
            except:
                print "\nDownload interrupted"
            if (os.stat(self.sfile).st_size == 0):
                os.remove(self.sfile)
    
    def downloaded(self):
        return True if os.path.exists(self.vfile) else False
    
    def label(self,showid=False):
        return self.date + " " +  self.time + " " + self.title

def cursor_hide():
    """
    Hide the terminal cursor to reduce UI clutter.
    """
    sys.stdout.write('\033[?25l')
    
def cursor_unhide():
    """
    Make the cursor visible again after being
    hidden during the download phase.
    """
    sys.stdout.write('\033[?25h')
    
# Usage message
def usage():
    print "Usage: tvkaista-download [-hvfupsd]"
    print ""
    print " Options:  -h --help          show this message"
    print "           -v                 print more information"
    print "           --prompt           prompt before downloading"
    print "           -s                 show list of favourites"
    print "           -u                 username"
    print "           -p                 password"
    print "           -f                 video format (iTunes/flv/h264/ts/help)"
    print "           -d                 download directory"
    print "           --alpha            use alpha.tvkaista.fi"
    print "           --seasons          download seasons feed"
    print "           --search keyword   search program index"
    print ""

# List available video formats.  
def show_format_info():
    print "Available video formats:"
    print " iTunes  300 kbps MPEG-4"
    print " flv       1 Mbps flash video"
    print " h264      2 Mbps MPEG-4"
    print " ts        8 Mbps MPEG-2 transport stream"

# On the first run, prompt the user for settings
def prompt_settings():
    settings = {}
    settings['username'] = raw_input("TVkaista username: ")
    settings['password'] = raw_input("TVkaista password: ")
    settings['format'] = "unknown"
    while (settings['format'] not in formats):
        if (settings['format']) == "help":
            show_format_info()
        settings['format'] = raw_input("File format (iTunes/flv/h264/ts): ")
    settings['downloaddir'] = raw_input("Download directory: ")
    for k in settings.keys():
        print "   " + k + ": " + settings[k]
    while (raw_input("Are these values ok (Y/n)? ") in ['n']):
        prompt_settings()
    return settings

# Write configuration file.  
# Format: option = value
def write_rcfile(settings):
    omask = os.umask(077)
    f = open(getconffile(), 'w')
    f.write("# Configuration file for tvkaista-download script\n")
    f.write("# http://code.google.com/p/tvkaista-download/\n")
    for k in settings.keys():
        f.write(k+" = " + settings[k] + "\n")
    f.close()
    os.umask(omask)

# Read configuration file.  
# Format: option = value
def read_rcfile(filename):
    config = {}
    f = open(filename)
    for line in f:
        if "#" in line:
            line, comment = line.split("#", 1)
        if "=" in line:
            # split on option char:
            key, value = line.split("=", 1)
            key = key.strip()
            value = value.strip()
            config[key] = value
    f.close()
    return config

# Transform month name abbreviations into numbers 1-12.  
def rfc822month(mon):
    return {
      'Jan': '01',
      'Feb': '02',
      'Mar': '03',
      'Apr': '04',
      'May': '05',
      'Jun': '06',
      'Jul': '07',
      'Aug': '08',
      'Sep': '09',
      'Oct': '10',
      'Nov': '11',
      'Dec': '12',
    }[mon]

# Filename suffix for a given video format
def filesuffix(format):
    return {
      'iTunes': 'mp4',
      'flv' :   'flv',
      'h264':   'mp4',
      'ts':     'ts'
    }[format]

# Map from format types into file suffices
def formatstring(format):
    return {
      'iTunes': 'mp4',
      'flv' :   'flv',
      'h264':   'h264',
      'ts':     'ts'
    }[format]

# Remove HTML encoding of strings
# Original code from tvkaistaforxbmc plugin
def unescape(text):
    def fixup(m):
        text = m.group(0)
        if text[:2] == "&#":
            try:
                if text[:3] == "&#x":
                    return unichr(int(text[3:-1], 16))
                else:
                    return unichr(int(text[2:-1]))
            except ValueError:
                pass
        else:
            try:
                text = unichr(htmlentitydefs.name2codepoint[text[1:-1]])
            except KeyError:
                pass
        return text
    return re.sub("&#?\w+;", fixup, text)

# Download the list of favorite recordings and build a list of download 
# targets. Original code from tvkaistaforxbmc plugin
def feedreader(feed):
    targets = []      
    passman = urllib2.HTTPPasswordMgrWithDefaultRealm()
    passman.add_password(None, feed, settings['username'], \
			 settings['password'])
    opener = urllib2.build_opener(urllib2.HTTPBasicAuthHandler(passman))
    urllib2.install_opener(opener)
    try:
        content = urllib2.urlopen(feed).read()
    except(urllib2.HTTPError):
        print "HTTP 404 Error: " + feed
        exit(1)
    dom = minidom.parseString(content)
    items = dom.getElementsByTagName('item')
    ret = []
    for i in items:
        ptit = i.getElementsByTagName('title')[0].childNodes[0].nodeValue
        pgui= i.getElementsByTagName('guid')[0].childNodes[0].nodeValue
        pdt = time.mktime(time.strptime(i.getElementsByTagName('pubDate')[0]\
	      .childNodes[0].nodeValue, "%a, %d %b %Y %H:%M:%S +0300"))
        pid = re.compile('http://www.tvkaista.fi/netpvr/Search[?]id=(\d+)')\
	      .findall(pgui)[0]
        program = Program(pid,ptit,0,pdt)
        if (prompt and not program.downloaded()):
            print program.label()
        if (prompt and raw_input('Download (Y/n) ') == 'n'):
            continue
        ret.append(program)
    dom.unlink()
    return ret

# Parse a list of download targets from a RSS file into a list of 
# downloadable objects
def feedreader_alpha(feed):
    targets = []      
    passman = urllib2.HTTPPasswordMgrWithDefaultRealm()
    passman.add_password(None, feed, settings['username'], \
			 settings['password'])
    opener = urllib2.build_opener(urllib2.HTTPBasicAuthHandler(passman))
    urllib2.install_opener(opener)
    try:
        content = urllib2.urlopen(feed).read()
    except(urllib2.HTTPError):
        print "HTTP 404 Error: " + feed
        exit(1)
    dom = minidom.parseString(content)
    items = dom.getElementsByTagName('item')
    ret = []
    for i in items:
        ptit = i.getElementsByTagName('title')[0].childNodes[0]\
	       .nodeValue.replace(" ","_")
        try:
            plen = i.getElementsByTagName('enclosure')[0].\
		   attributes['length'].value
        except:
            plen = 0
        plin= i.getElementsByTagName('link')[0].childNodes[0].nodeValue
        pdt = time.mktime(time.strptime(i.getElementsByTagName('pubDate')[0]\
	      .childNodes[0].nodeValue, "%a, %d %b %Y %H:%M:%S +0000"))
        pid = re.compile('http://alpha.tvkaista.fi/search/[?]id=(\d+)')\
	      .findall(plin)[0]
        program = Program(pid,ptit,plen,pdt)
        if (prompt and not program.downloaded()):
            print program.label()
        if (prompt and raw_input('Download (Y/n) ') == 'n'):
            continue
        ret.append(program)
    dom.unlink()
    return ret

# Format raw byte count into reasonable units.  
def dataformat(b):
    if (b < 1024):
        return "%d bytes" % b
    b = b / 1024
    if (b < 1024):
       return "%.2f KiB" % b
    b = b / 1024
    if (b < 1024):
        return "%.2f MiB" % b
    b = b / 1024
    return "%.2f GiB" % b
    
def timeformat(s):
    if s < 0:
        return "00:00:00"
    h = floor(s / 3600)
    s = s - h * 3600
    m = floor(s / 60)
    s = s - m * 60
    return "%02d:%02d:%02d" % (h,m,s)

# Progress bar display for urllib.urlretrieve function.  
def progressbar(count, blockSize, totalSize):
    if (totalSize > 0):
        percent = int(count * blockSize * 100 / totalSize)
        blocks = int(count * blockSize * BAR_WIDTH / totalSize)
    else:
        percent = 0
        blocks = 0
    sys.stdout.write("\r[" + blocks * "=" + (BAR_WIDTH - blocks) * ' ' + \
		     "] " + "%d%% " % percent)
    sys.stdout.write('of %s ' % dataformat(totalSize))
    bps_speed = count * blockSize / timer.gettime()
    sys.stdout.write('at %s/s ' % dataformat(bps_speed))
    if bps_speed > 0:
        eta = (totalSize - count * blockSize) / (bps_speed)
    else:
        eta = 0
    sys.stdout.write('ETA: %s' % timeformat(eta))
    sys.stdout.write(4 * ' ')
    sys.stdout.flush()

# Return a suitable file name for configuration options.  
def getconffile():
    # TODO: OS specific selection of configuration file name.  
    return os.getenv("HOME") + "/.tvkaista-downloadrc"

# Confirm that all required settings have been defined.  
def valid_settings(s,critical):
    for k in att:
        try:
            if (s[k] == None):
                if (critical):
                    print k + " not specified. See \"tvkaista-download --help\""
                    sys.exit(1)
                else:
                    return False
        except KeyError:
            if (critical):
                print k + " not specified. See \"tvkaista-download --help\""
                sys.exit(1)
            else:
                return False
    return True

# Main program
def main(argv):

    global conffile
    global verbose
    global prompt
    global show
    global settings
    global timer
    global alpha
    global mode_season
    global mode_search
    
    timer = Timer()
    exp_settings = {}

    # Processing of command line options using getopt.  
    try:
        opts, args = getopt.getopt(argv, "hvpsf:u:p:d:", \
                       ["help","verbose","prompt","show","format=","username=",\
                        "password=","downloaddir=","alpha","seasons","search="])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()                     
            sys.exit()
        if opt in ("-v", "--verbose"):
            verbose = True
        if (opt == "--prompt"):
            prompt = True
        if (opt == "--alpha"):
            alpha = True
        if (opt == "--seasons"):
            mode_season = True
        if opt in ("-s", "--show"):
            show = True
        if opt in ("-f", "--format"):
            exp_settings['format'] = arg
        if opt in ("-u", "--username"):
            exp_settings['username'] = arg
        if (opt == "--search"):
            mode_search = True
            search_terms = arg       
        if opt in ("-p", "--password"):
            exp_settings['password'] = arg
        if opt in ("-d", "--downloaddir"):
            exp_settings['downloaddir'] = arg
    
    # First see whether a configuration file is available.  
    conffile = getconffile()

    if os.path.exists(conffile):
        if (verbose):
            print "Reading configuration from " + conffile
        settings = read_rcfile(conffile)
    else:
        if (not valid_settings(exp_settings, False)):
            settings = prompt_settings()
            write_rcfile(settings)
        
    # Override configuration file if necessary.  
    settings.update(exp_settings)

    # Make sure that all required settings have been defined.  
    valid_settings(settings, True)

    # Debug: print all settings
    #for k in att:
    #    print k+": "+settings[k]
    
    #if sum([mode_search,mode_season]) > 1:
    if mode_search and mode_season:
        print "Options --search and --seasons cannot be used together."
        sys.exit(0)
        
    if prompt and show:
        print "Options --prompt and --show cannot be used together."
        sys.exit(0)
    
    if (mode_search):
        if (alpha):
            feed = "http://alpha.tvkaista.fi/feed/search/title/" + \
            urllib.urlencode({'':search_terms})[1:] + "/" + \
            formatstring(settings['format'])+".rss"
        else:
            feed = "http://www.tvkaista.fi/netpvr/Feed?channel=search&" + \
            urllib.urlencode({'search':search_terms}) + \
            "&format=" + formatstring(settings['format']) + "&extension=rss"
    elif (mode_season):
        if (alpha):
            feed = 'http://alpha.tvkaista.fi/feed/seasonpasses/*/' + \
            formatstring(settings['format']) + '.rss'
        else:
            feed = 'http://www.tvkaista.fi/netpvr/Feed?channel=seasonpass&format=' + \
            formatstring(settings['format']) + '&extension=itunes'
    else:
        if (alpha):
            feed = 'http://alpha.tvkaista.fi/feed/playlist/' + \
            formatstring(settings['format']) + '.rss'
        else:
            feed = "http://www.tvkaista.fi/netpvr/Feed?channel=Playlist&format=" + \
            settings['format'] + "&extension=itunes"
    
    targets = feedreader_alpha(feed) if alpha else feedreader(feed)

    # Show list "-s"
    if (show):
        for t in targets:
            box = '[*] ' if t.downloaded() else '[ ] '
            print box + t.label()
    else:
        [t.download() for t in targets]
    sys.exit(0)

# File name suffix for incomplete downloads
TMP_SUFFIX = '.part'
SUB_SUFFIX = '.srt'
# Progress bar width
BAR_WIDTH = 70
settings = {}
# Required configuration options
att = ['username','password','format','downloaddir']
# Available video formats
formats = ['iTunes','flv','h264','ts']
verbose = False
prompt = False
show = False
alpha = False
mode_season = False
mode_search = False

if __name__ == "__main__":
    main(sys.argv[1:])

